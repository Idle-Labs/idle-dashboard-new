{"version":3,"file":"static/js/4202.6cf77cda.chunk.js","mappings":"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","sources":["../node_modules/eccrypto/browser.js","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/wallet/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/create-identity.js","../node_modules/eth-crypto/dist/es/util.js","../node_modules/eth-crypto/dist/es/public-key.js","../node_modules/eth-crypto/dist/es/cipher.js","../node_modules/eth-crypto/dist/es/decrypt-with-private-key.js","../node_modules/eth-crypto/dist/es/encrypt-with-public-key.js","../node_modules/eth-crypto/dist/es/public-key-by-private-key.js","../node_modules/eth-crypto/dist/es/recover-public-key.js","../node_modules/eth-crypto/dist/es/recover.js","../node_modules/eth-crypto/dist/es/sign.js","../node_modules/eth-crypto/dist/es/sign-transaction.js","../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/eth-crypto/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/contracts/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/tx-data-by-compiled.js","../node_modules/eth-crypto/dist/es/calculate-contract-address.js","../node_modules/eth-crypto/node_modules/@ethersproject/solidity/src.ts/index.ts","../node_modules/eth-crypto/node_modules/@ethersproject/solidity/src.ts/_version.ts","../node_modules/eth-crypto/dist/es/hash.js","../node_modules/eth-crypto/dist/es/hex.js","../node_modules/eth-crypto/dist/es/vrs.js","../node_modules/eth-crypto/dist/es/index.js"],"sourcesContent":["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider, TransactionRequest } from \"@ethersproject/abstract-provider\";\nimport { ExternallyOwnedAccount, Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { arrayify, Bytes, BytesLike, concat, hexDataSlice, isHexString, joinSignature, SignatureLike } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic, Mnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore, ProgressCallback } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize, UnsignedTransaction } from \"@ethersproject/transactions\";\nimport { Wordlist } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value: any): value is ExternallyOwnedAccount {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\n\nfunction hasMnemonic(value: any): value is { mnemonic: Mnemonic } {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\n\nexport class Wallet extends Signer implements ExternallyOwnedAccount, TypedDataSigner {\n\n    readonly address: string;\n    readonly provider: Provider;\n\n    // Wrapping the _signingKey and _mnemonic in a getter function prevents\n    // leaking the private key in console.log; still, be careful! :)\n    readonly _signingKey: () => SigningKey;\n    readonly _mnemonic: () => Mnemonic;\n\n    constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider) {\n        super();\n\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => (\n                    {\n                        phrase: srcMnemonic.phrase,\n                        path: srcMnemonic.path || defaultPath,\n                        locale: srcMnemonic.locale || \"en\"\n                    }\n                ));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            } else {\n                defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            }\n\n\n        } else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => (<SigningKey>privateKey));\n\n            } else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof(privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n\n            defineReadOnly(this, \"_mnemonic\", (): Mnemonic => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    get mnemonic(): Mnemonic { return this._mnemonic(); }\n    get privateKey(): string { return this._signingKey().privateKey; }\n    get publicKey(): string { return this._signingKey().publicKey; }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    connect(provider: Provider): Wallet {\n        return new Wallet(this, provider);\n    }\n\n    signTransaction(transaction: TransactionRequest): Promise<string> {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n\n            const signature = this._signingKey().signDigest(keccak256(serialize(<UnsignedTransaction>tx)));\n            return serialize(<UnsignedTransaction>tx, signature);\n        });\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            if (this.provider == null) {\n                logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"resolveName\",\n                    value: name\n                });\n            }\n            return this.provider.resolveName(name);\n        });\n\n        return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    }\n\n    encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string> {\n        if (typeof(options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n\n        if (progressCallback && typeof(progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n\n        if (!options) { options = {}; }\n\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n\n\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options?: any): Wallet {\n        let entropy: Uint8Array = randomBytes(16);\n\n        if (!options) { options = { }; }\n\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([ entropy, options.extraEntropy ])), 0, 16));\n        }\n\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n\n    static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet> {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n\n    static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n\n    static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet {\n        if (!path) { path = defaultPath; }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\n\nexport function verifyMessage(message: Bytes | string, signature: SignatureLike): string {\n    return recoverAddress(hashMessage(message), signature);\n}\n\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n","export const version = \"wallet/5.7.0\";\n","import { utils as ethersUtils, Wallet } from 'ethers';\nimport { stripHexPrefix } from 'ethereumjs-util';\nvar MIN_ENTROPY_SIZE = 128;\nvar keccak256 = ethersUtils.keccak256;\n\n/**\n * create a privateKey from the given entropy or a new one\n * @param  {Buffer} entropy\n * @return {string}\n */\nexport function createPrivateKey(entropy) {\n  if (entropy) {\n    if (!Buffer.isBuffer(entropy)) throw new Error('EthCrypto.createPrivateKey(): given entropy is no Buffer');\n    if (Buffer.byteLength(entropy, 'utf8') < MIN_ENTROPY_SIZE) throw new Error('EthCrypto.createPrivateKey(): Entropy-size must be at least ' + MIN_ENTROPY_SIZE);\n    var outerHex = keccak256(entropy);\n    return outerHex;\n  } else {\n    var innerHex = keccak256(ethersUtils.concat([ethersUtils.randomBytes(32), ethersUtils.randomBytes(32)]));\n    var middleHex = ethersUtils.concat([ethersUtils.concat([ethersUtils.randomBytes(32), innerHex]), ethersUtils.randomBytes(32)]);\n    var _outerHex = keccak256(middleHex);\n    return _outerHex;\n  }\n}\n\n/**\n * creates a new object with\n * private-, public-Key and address\n * @param {Buffer?} entropy if provided, will use that as single random-source\n */\nexport default function createIdentity(entropy) {\n  var privateKey = createPrivateKey(entropy);\n  var wallet = new Wallet(privateKey);\n  var identity = {\n    privateKey: privateKey,\n    // remove trailing '0x04'\n    publicKey: stripHexPrefix(wallet.publicKey).slice(2),\n    address: wallet.address\n  };\n  return identity;\n}","export function removeLeading0x(str) {\n  if (str.startsWith('0x')) return str.substring(2);else return str;\n}\nexport function addLeading0x(str) {\n  if (!str.startsWith('0x')) return '0x' + str;else return str;\n}\nexport function uint8ArrayToHex(arr) {\n  return Buffer.from(arr).toString('hex');\n}\nexport function hexToUnit8Array(str) {\n  return new Uint8Array(Buffer.from(str, 'hex'));\n}","import { publicKeyConvert } from 'secp256k1';\nimport { pubToAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { hexToUnit8Array, uint8ArrayToHex, addLeading0x } from './util';\nexport function compress(startsWith04) {\n  // add trailing 04 if not done before\n  var testBuffer = Buffer.from(startsWith04, 'hex');\n  if (testBuffer.length === 64) startsWith04 = '04' + startsWith04;\n  return uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith04), true));\n}\nexport function decompress(startsWith02Or03) {\n  // if already decompressed an not has trailing 04\n  var testBuffer = Buffer.from(startsWith02Or03, 'hex');\n  if (testBuffer.length === 64) startsWith02Or03 = '04' + startsWith02Or03;\n  var decompressed = uint8ArrayToHex(publicKeyConvert(hexToUnit8Array(startsWith02Or03), false));\n\n  // remove trailing 04\n  decompressed = decompressed.substring(2);\n  return decompressed;\n}\n\n/**\n * generates the ethereum-adress of the publicKey\n * We create the checksum-adress which is case-sensitive\n * @returns {string} address\n */\nexport function toAddress(publicKey) {\n  // normalize key\n  publicKey = decompress(publicKey);\n  var addressBuffer = pubToAddress(toBuffer(addLeading0x(publicKey)));\n  var checkSumAdress = toChecksumAddress(addLeading0x(addressBuffer.toString('hex')));\n  return checkSumAdress;\n}","import { compress, decompress } from './public-key';\nexport function stringify(cipher) {\n  if (typeof cipher === 'string') return cipher;\n\n  // use compressed key because it's smaller\n  var compressedKey = compress(cipher.ephemPublicKey);\n  var ret = Buffer.concat([Buffer.from(cipher.iv, 'hex'),\n  // 16bit\n  Buffer.from(compressedKey, 'hex'),\n  // 33bit\n  Buffer.from(cipher.mac, 'hex'),\n  // 32bit\n  Buffer.from(cipher.ciphertext, 'hex') // var bit\n  ]);\n\n  return ret.toString('hex');\n}\nexport function parse(str) {\n  if (typeof str !== 'string') return str;\n  var buf = Buffer.from(str, 'hex');\n  var ret = {\n    iv: buf.toString('hex', 0, 16),\n    ephemPublicKey: buf.toString('hex', 16, 49),\n    mac: buf.toString('hex', 49, 81),\n    ciphertext: buf.toString('hex', 81, buf.length)\n  };\n\n  // decompress publicKey\n  ret.ephemPublicKey = '04' + decompress(ret.ephemPublicKey);\n  return ret;\n}","import { decrypt } from 'eccrypto';\nimport { parse } from './cipher';\nimport { removeLeading0x } from './util';\nexport default function decryptWithPrivateKey(privateKey, encrypted) {\n  encrypted = parse(encrypted);\n\n  // remove trailing '0x' from privateKey\n  var twoStripped = removeLeading0x(privateKey);\n  var encryptedBuffer = {\n    iv: Buffer.from(encrypted.iv, 'hex'),\n    ephemPublicKey: Buffer.from(encrypted.ephemPublicKey, 'hex'),\n    ciphertext: Buffer.from(encrypted.ciphertext, 'hex'),\n    mac: Buffer.from(encrypted.mac, 'hex')\n  };\n  return decrypt(Buffer.from(twoStripped, 'hex'), encryptedBuffer).then(function (decryptedBuffer) {\n    return decryptedBuffer.toString();\n  });\n}","import { encrypt } from 'eccrypto';\nimport { decompress } from './public-key';\nexport default function encryptWithPublicKey(publicKey, message, opts) {\n  // ensure its an uncompressed publicKey\n  publicKey = decompress(publicKey);\n\n  // re-add the compression-flag\n  var pubString = '04' + publicKey;\n  return encrypt(Buffer.from(pubString, 'hex'), Buffer.from(message), opts ? opts : {}).then(function (encryptedBuffers) {\n    var encrypted = {\n      iv: encryptedBuffers.iv.toString('hex'),\n      ephemPublicKey: encryptedBuffers.ephemPublicKey.toString('hex'),\n      ciphertext: encryptedBuffers.ciphertext.toString('hex'),\n      mac: encryptedBuffers.mac.toString('hex')\n    };\n    return encrypted;\n  });\n}","import { privateToPublic, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\n\n/**\n * Generate publicKey from the privateKey.\n * This creates the uncompressed publicKey,\n * where 04 has stripped from left\n * @returns {string}\n */\nexport default function publicKeyOfPrivateKey(privateKey) {\n  privateKey = addLeading0x(privateKey);\n  var publicKeyBuffer = privateToPublic(toBuffer(privateKey));\n  return publicKeyBuffer.toString('hex');\n}","import { ecdsaRecover } from 'secp256k1';\nimport { removeLeading0x, hexToUnit8Array, uint8ArrayToHex } from './util';\n\n/**\n * returns the publicKey for the privateKey with which the messageHash was signed\n * @param  {string} signature\n * @param  {string} hash\n * @return {string} publicKey\n */\nexport default function recoverPublicKey(signature, hash) {\n  signature = removeLeading0x(signature);\n\n  // split into v-value and sig\n  var sigOnly = signature.substring(0, signature.length - 2); // all but last 2 chars\n  var vValue = signature.slice(-2); // last 2 chars\n\n  var recoveryNumber = vValue === '1c' ? 1 : 0;\n  var pubKey = uint8ArrayToHex(ecdsaRecover(hexToUnit8Array(sigOnly), recoveryNumber, hexToUnit8Array(removeLeading0x(hash)), false));\n\n  // remove trailing '04'\n  pubKey = pubKey.slice(2);\n  return pubKey;\n}","import recoverPublicKey from './recover-public-key';\nimport { toAddress as addressByPublicKey } from './public-key';\n\n/**\n * returns the adress with which the messageHash was signed\n * @param  {string} sigString\n * @param  {string} hash\n * @return {string} address\n */\nexport default function recover(sigString, hash) {\n  var pubkey = recoverPublicKey(sigString, hash);\n  var address = addressByPublicKey(pubkey);\n  return address;\n}","import { ecdsaSign as secp256k1_sign } from 'secp256k1';\nimport { addLeading0x, removeLeading0x } from './util';\n\n/**\n * signs the given message\n * we do not use sign from eth-lib because the pure secp256k1-version is 90% faster\n * @param  {string} privateKey\n * @param  {string} hash\n * @return {string} hexString\n */\nexport default function sign(privateKey, hash) {\n  hash = addLeading0x(hash);\n  if (hash.length !== 66) throw new Error('EthCrypto.sign(): Can only sign hashes, given: ' + hash);\n  var sigObj = secp256k1_sign(new Uint8Array(Buffer.from(removeLeading0x(hash), 'hex')), new Uint8Array(Buffer.from(removeLeading0x(privateKey), 'hex')));\n  var recoveryId = sigObj.recid === 1 ? '1c' : '1b';\n  var newSignature = '0x' + Buffer.from(sigObj.signature).toString('hex') + recoveryId;\n  return newSignature;\n}","import { Transaction } from '@ethereumjs/tx';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport { toAddress as addressByPublicKey } from './public-key';\nexport default function signTransaction(rawTx, privateKey) {\n  var txOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // check if privateKey->address matches rawTx.from\n  var publicKey = publicKeyByPrivateKey(privateKey);\n  var address = addressByPublicKey(publicKey);\n  if (address != rawTx.from) throw new Error('EthCrypto.signTransaction(): rawTx.from does not match the address of the privateKey');\n  var privateKeyBuffer = Buffer.from(privateKey.replace(/^.{2}/g, ''), 'hex');\n  var tx = Transaction.fromTxData(rawTx, txOptions);\n  var signedTx = tx.sign(privateKeyBuffer);\n  var serializedTx = signedTx.serialize().toString('hex');\n  return serializedTx;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","\"use strict\";\n\nimport { checkResultErrors, EventFragment, Fragment, FunctionFragment, Indexed, Interface, JsonFragment, LogDescription, ParamType, Result } from \"@ethersproject/abi\";\nimport { Block, BlockTag, Filter, FilterByBlockHash, Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, AccessListish } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\nexport interface Overrides {\n    gasLimit?: BigNumberish | Promise<BigNumberish>;\n    gasPrice?: BigNumberish | Promise<BigNumberish>;\n    maxFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    maxPriorityFeePerGas?: BigNumberish | Promise<BigNumberish>;\n    nonce?: BigNumberish | Promise<BigNumberish>;\n    type?: number;\n    accessList?: AccessListish;\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport interface PayableOverrides extends Overrides {\n    value?: BigNumberish | Promise<BigNumberish>;\n}\n\nexport interface CallOverrides extends PayableOverrides {\n    blockTag?: BlockTag | Promise<BlockTag>;\n    from?: string | Promise<string>;\n}\n\n// @TODO: Better hierarchy with: (in v6)\n//  - abstract-provider:TransactionRequest\n//  - transactions:Transaction\n//  - transaction:UnsignedTransaction\n\nexport interface PopulatedTransaction {\n    to?: string;\n    from?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumber;\n    gasPrice?: BigNumber;\n\n    data?: string;\n    value?: BigNumber;\n    chainId?: number;\n\n    type?: number;\n    accessList?: AccessList;\n\n    maxFeePerGas?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n};\n\nexport type EventFilter = {\n    address?: string;\n    topics?: Array<string|Array<string>>;\n};\n\n\nexport type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>;\n\n\n// The (n + 1)th parameter passed to contract event callbacks\nexport interface Event extends Log {\n\n    // The event name\n    event?: string;\n\n    // The event signature\n    eventSignature?: string;\n\n    // The parsed arguments to the event\n    args?: Result;\n\n    // If parsing the arguments failed, this is the error\n    decodeError?: Error;\n\n    // A function that can be used to decode event data and topics\n    decode?: (data: string, topics?: Array<string>) => any;\n\n    // A function that will remove the listener responsible for this event (if any)\n    removeListener: () => void;\n\n    // Get blockchain details about this event's block and transaction\n    getBlock: () => Promise<Block>;\n    getTransaction: () => Promise<TransactionResponse>;\n    getTransactionReceipt: () => Promise<TransactionReceipt>;\n}\n\nexport interface ContractReceipt extends TransactionReceipt {\n    events?: Array<Event>;\n}\n\nexport interface ContractTransaction extends TransactionResponse {\n    wait(confirmations?: number): Promise<ContractReceipt>;\n}\n\n///////////////////////////////\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n}\n\nasync function resolveName(resolver: Signer | Provider, nameOrPromise: string | Promise<string>): Promise<string> {\n    const name = await nameOrPromise;\n\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    }\n\n    // If it is already an address, just use it (after adding checksum)\n    try {\n        return getAddress(name);\n    } catch (error) { }\n\n    if (!resolver) {\n        logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\"\n        });\n    }\n\n    const address = await resolver.resolveName(name);\n\n    if (address == null) {\n        logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n}\n\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nasync function resolveAddresses(resolver: Signer | Provider, value: any, paramType: ParamType | Array<ParamType>): Promise<any> {\n    if (Array.isArray(paramType)) {\n        return await Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(\n                resolver,\n                ((Array.isArray(value)) ? value[index]: value[paramType.name]),\n                paramType\n            );\n        }));\n    }\n\n    if (paramType.type === \"address\") {\n        return await resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n        return await resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                argument: \"value\",\n                value\n            }));\n        }\n        return await Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n}\n\nasync function populateTransaction(contract: Contract, fragment: FunctionFragment, args: Array<any>): Promise<PopulatedTransaction> {\n    // If an extra argument is given, it is overrides\n    let overrides: CallOverrides = { };\n    if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n        overrides = shallowCopy(args.pop());\n    }\n\n    // Make sure the parameter count matches\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n\n    // Populate \"from\" override (allow promises)\n    if (contract.signer) {\n        if (overrides.from) {\n            // Contracts with a Signer are from the Signer's frame-of-reference;\n            // but we allow overriding \"from\" if it matches the signer\n            overrides.from = resolveProperties({\n                override: resolveName(contract.signer, overrides.from),\n                signer: contract.signer.getAddress()\n            }).then(async (check) => {\n                if (getAddress(check.signer) !== check.override) {\n                    logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"overrides.from\"\n                    });\n                }\n\n                return check.override;\n            });\n\n        } else {\n            overrides.from = contract.signer.getAddress();\n        }\n\n    } else if (overrides.from) {\n        overrides.from = resolveName(contract.provider, overrides.from);\n\n    //} else {\n        // Contracts without a signer can override \"from\", and if\n        // unspecified the zero address is used\n        //overrides.from = AddressZero;\n    }\n\n    // Wait for all dependencies to be resolved (prefer the signer over the provider)\n    const resolved = await resolveProperties({\n        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n        address: contract.resolvedAddress,\n        overrides: (resolveProperties(overrides) || { })\n    });\n\n    // The ABI coded transaction\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx: PopulatedTransaction = {\n      data: data,\n      to: resolved.address\n    };\n\n    // Resolved Overrides\n    const ro = resolved.overrides;\n\n    // Populate simple overrides\n    if (ro.nonce != null) { tx.nonce = BigNumber.from(ro.nonce).toNumber(); }\n    if (ro.gasLimit != null) { tx.gasLimit = BigNumber.from(ro.gasLimit); }\n    if (ro.gasPrice != null) { tx.gasPrice = BigNumber.from(ro.gasPrice); }\n    if (ro.maxFeePerGas != null) { tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas); }\n    if (ro.maxPriorityFeePerGas != null) { tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas); }\n    if (ro.from != null) { tx.from = ro.from; }\n\n    if (ro.type != null) { tx.type = ro.type; }\n    if (ro.accessList != null) { tx.accessList = accessListify(ro.accessList); }\n\n    // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n    if (tx.gasLimit == null && fragment.gas != null) {\n        // Compute the intrinsic gas cost for this transaction\n        // @TODO: This is based on the yellow paper as of Petersburg; this is something\n        // we may wish to parameterize in v6 as part of the Network object. Since this\n        // is always a non-nil to address, we can ignore G_create, but may wish to add\n        // similar logic to the ContractFactory.\n        let intrinsic = 21000;\n        const bytes = arrayify(data);\n        for (let i = 0; i < bytes.length; i++) {\n            intrinsic += 4;\n            if (bytes[i]) { intrinsic += 64; }\n        }\n        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    }\n\n    // Populate \"value\" override\n    if (ro.value) {\n        const roValue = BigNumber.from(ro.value);\n        if (!roValue.isZero() && !fragment.payable) {\n            logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides.value\",\n                value: overrides.value\n            });\n        }\n        tx.value = roValue;\n    }\n\n    if (ro.customData) {\n        tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n        tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    }\n\n    // Remove the overrides\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n\n    delete overrides.type;\n    delete overrides.accessList;\n\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled;\n\n    // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n    const leftovers = Object.keys(overrides).filter((key) => ((<any>overrides)[key] != null));\n    if (leftovers.length) {\n        logger.throwError(`cannot override ${ leftovers.map((l) => JSON.stringify(l)).join(\",\") }`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"overrides\",\n            overrides: leftovers\n        });\n    }\n\n    return tx;\n}\n\n\nfunction buildPopulate(contract: Contract, fragment: FunctionFragment): ContractFunction<PopulatedTransaction> {\n    return function(...args: Array<any>): Promise<PopulatedTransaction> {\n        return populateTransaction(contract, fragment, args);\n    };\n}\n\nfunction buildEstimate(contract: Contract, fragment: FunctionFragment): ContractFunction<BigNumber> {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return async function(...args: Array<any>): Promise<BigNumber> {\n        if (!signerOrProvider) {\n            logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"estimateGas\"\n            })\n        }\n\n        const tx = await populateTransaction(contract, fragment, args);\n        return await signerOrProvider.estimateGas(tx);\n    };\n}\n\nfunction addContractWait(contract: Contract, tx: TransactionResponse) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations?: number) => {\n        return wait(confirmations).then((receipt: ContractReceipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event: Event = (<Event>deepCopy(log));\n                let parsed: LogDescription = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                } catch (e){ }\n\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data: BytesLike, topics?: Array<any>) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n\n                // Useful operations\n                event.removeListener = () => { return contract.provider; }\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                }\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                }\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                }\n\n                return event;\n            });\n\n            return receipt;\n        });\n    };\n}\n\nfunction buildCall(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    const signerOrProvider = (contract.signer || contract.provider);\n\n    return async function(...args: Array<any>): Promise<any> {\n        // Extract the \"blockTag\" override if present\n        let blockTag = undefined;\n        if (args.length === fragment.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            const overrides = shallowCopy(args.pop());\n            if (overrides.blockTag != null) {\n                blockTag = await overrides.blockTag;\n            }\n            delete overrides.blockTag;\n            args.push(overrides);\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed(blockTag);\n        }\n\n        // Call a node and get the result\n        const tx = await populateTransaction(contract, fragment, args);\n        const result = await signerOrProvider.call(tx, blockTag);\n\n        try {\n            let value = contract.interface.decodeFunctionResult(fragment, result);\n            if (collapseSimple && fragment.outputs.length === 1) {\n                value = value[0];\n            }\n            return value;\n\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n                error.address = contract.address;\n                error.args = args;\n                error.transaction = tx;\n            }\n            throw error;\n         }\n    };\n}\n\nfunction buildSend(contract: Contract, fragment: FunctionFragment): ContractFunction<TransactionResponse> {\n    return async function(...args: Array<any>): Promise<TransactionResponse> {\n        if (!contract.signer) {\n            logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"sendTransaction\"\n            })\n        }\n\n        // If the contract was just deployed, wait until it is mined\n        if (contract.deployTransaction != null) {\n            await contract._deployed();\n        }\n\n        const txRequest = await populateTransaction(contract, fragment, args);\n\n        const tx = await contract.signer.sendTransaction(txRequest);\n\n        // Tweak the tx.wait so the receipt has extra properties\n        addContractWait(contract, tx);\n\n        return tx;\n    };\n}\n\nfunction buildDefault(contract: Contract, fragment: FunctionFragment, collapseSimple: boolean): ContractFunction {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter: EventFilter): string {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\"): \"\");\n}\n\nclass RunningEvent {\n    readonly tag: string;\n    readonly filter: EventFilter;\n    private _listeners: Array<{ listener: Listener, once: boolean }>;\n\n    constructor(tag: string, filter: EventFilter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [ ];\n    }\n\n    addListener(listener: Listener, once: boolean): void {\n        this._listeners.push({ listener: listener, once: once });\n    }\n\n    removeListener(listener: Listener): void {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) { return true; }\n            done = true;\n            return false;\n        });\n    }\n\n    removeAllListeners(): void {\n        this._listeners = [];\n    }\n\n    listeners(): Array<Listener> {\n        return this._listeners.map((i) => i.listener);\n    }\n\n    listenerCount(): number {\n        return this._listeners.length;\n    }\n\n    run(args: Array<any>): number {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n\n            const argsCopy = args.slice();\n\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n\n        return listenerCount;\n    }\n\n    prepareEvent(event: Event): void {\n    }\n\n    // Returns the array that will be applied to an emit\n    getEmit(event: Event): Array<any> {\n        return [ event ];\n    }\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n\n\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n    readonly fragment: EventFragment;\n\n    constructor(address: string, contractInterface: Interface, fragment: EventFragment, topics?: Array<string|Array<string>>) {\n        const filter: EventFilter = {\n            address: address\n        }\n\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) { logger.throwArgumentError(\"topic mismatch\", \"topics\", topics); }\n            filter.topics = topics.slice();\n        } else {\n            filter.topics = [ topic ];\n        }\n\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n\n        event.decode = (data: BytesLike, topics?: Array<string>) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        } catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n\n    getEmit(event: Event): Array<any> {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) { throw errors[0].error; }\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    readonly address: string;\n    readonly interface: Interface;\n\n    constructor(address: string, contractInterface: Interface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n\n    prepareEvent(event: Event): void {\n        super.prepareEvent(event);\n\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n\n            event.decode = (data: BytesLike, topics?: Array<string>) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n\n            event.args = parsed.args;\n        } catch (error) {\n            // No matching event\n        }\n    }\n}\n\nexport type ContractInterface = string | ReadonlyArray<Fragment | JsonFragment | string> | Interface;\n\ntype InterfaceFunc = (contractInterface: ContractInterface) => Interface;\n\n\nexport class BaseContract {\n    readonly address: string;\n    readonly interface: Interface;\n\n    readonly signer: Signer;\n    readonly provider: Provider;\n\n    readonly functions: { [ name: string ]: ContractFunction };\n\n    readonly callStatic: { [ name: string ]: ContractFunction };\n    readonly estimateGas: { [ name: string ]: ContractFunction<BigNumber> };\n    readonly populateTransaction: { [ name: string ]: ContractFunction<PopulatedTransaction> };\n\n    readonly filters: { [ name: string ]: (...args: Array<any>) => EventFilter };\n\n    // This will always be an address. This will only differ from\n    // address if an ENS name was used in the constructor\n    readonly resolvedAddress: Promise<string>;\n\n    // This is only set if the contract was created with a call to deploy\n    readonly deployTransaction: TransactionResponse;\n\n    _deployedPromise: Promise<Contract>;\n\n    // A list of RunningEvents to track listeners for each event tag\n    _runningEvents: { [ eventTag: string ]: RunningEvent };\n\n    // Wrapped functions to call emit and allow deregistration from the provider\n    _wrappedEmits: { [ eventTag: string ]: (...args: Array<any>) => void };\n\n    constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider) {\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        } else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        } else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        } else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n\n        defineReadOnly(this, \"callStatic\", { });\n        defineReadOnly(this, \"estimateGas\", { });\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"populateTransaction\", { });\n\n        defineReadOnly(this, \"filters\", { });\n\n        {\n            const uniqueFilters: { [ name: string ]: Array<string> } = { };\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args: Array<any>) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                   }\n                });\n                if (!uniqueFilters[event.name]) { uniqueFilters[event.name] = [ ]; }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                } else {\n                    logger.warn(`Duplicate definition of ${ name } (${ filters.join(\", \")})`);\n                }\n            });\n        }\n\n        defineReadOnly(this, \"_runningEvents\", { });\n        defineReadOnly(this, \"_wrappedEmits\", { });\n\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        } else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            } catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n\n        const uniqueNames: { [ name: string ]: Array<string> } = { };\n        const uniqueSignatures: { [ signature: string ]: boolean } = { };\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${ JSON.stringify(signature) }`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${ name }`]) { uniqueNames[`%${ name }`] = [ ]; }\n                uniqueNames[`%${ name }`].push(signature);\n            }\n\n            if ((<Contract>this)[signature] == null) {\n                defineReadOnly<any, any>(this, signature, buildDefault(this, fragment, true));\n            }\n\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) { return; }\n\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n\n            const signature = signatures[0];\n\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if ((<Contract>this)[name] == null) {\n                    defineReadOnly(<Contract>this, name, (<Contract>this)[signature]);\n                }\n            } catch (e) { }\n\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n\n    static getContractAddress(transaction: { from: string, nonce: BigNumberish }): string {\n        return getContractAddress(transaction);\n    }\n\n    static getInterface(contractInterface: ContractInterface): Interface {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n\n    // @TODO: Allow timeout?\n    deployed(): Promise<Contract> {\n        return this._deployed();\n    }\n\n    _deployed(blockTag?: BlockTag): Promise<Contract> {\n        if (!this._deployedPromise) {\n\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n\n            } else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n\n        return this._deployedPromise;\n    }\n\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n    fallback(overrides?: TransactionRequest): Promise<TransactionResponse> {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" })\n        }\n\n        const tx: Deferrable<TransactionRequest> = shallowCopy(overrides || {});\n\n        [\"from\", \"to\"].forEach(function(key) {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider: Signer | Provider | string): Contract {\n        if (typeof(signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n\n        const contract = new (<{ new(...args: any[]): Contract }>(this.constructor))(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n\n        return contract;\n    }\n\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName: string): Contract {\n        return new (<{ new(...args: any[]): Contract }>(this.constructor))(addressOrName, this.interface, this.signer || this.provider);\n    }\n\n    static isIndexed(value: any): value is Indexed {\n        return Indexed.isIndexed(value);\n    }\n\n    private _normalizeRunningEvent(runningEvent: RunningEvent): RunningEvent {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n         }\n         return runningEvent\n    }\n\n    private _getRunningEvent(eventName: EventFilter | string): RunningEvent {\n        if (typeof(eventName) === \"string\") {\n\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName)\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof(topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            } catch (error) { }\n\n            // Filter by the unknown topichash\n            const filter: EventFilter = {\n                address: this.address,\n                topics: eventName.topics\n            }\n\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n\n    _checkRunningEvents(runningEvent: RunningEvent): void {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event {\n        const event = <Event>deepCopy(log);\n\n        event.removeListener = () => {\n            if (!listener) { return; }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); }\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); }\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); }\n\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n\n        return event;\n    }\n\n    private _addEventListener(runningEvent: RunningEvent, listener: Listener, once: boolean): void {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" })\n        }\n\n        runningEvent.addListener(listener, once);\n\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log: Log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    } catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n\n    queryFilter(event: EventFilter | string, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>> {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n\n        if (typeof(fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            (<FilterByBlockHash>filter).blockHash = fromBlockOrBlockhash;\n        } else {\n             (<Filter>filter).fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash: 0);\n             (<Filter>filter).toBlock = ((toBlock != null) ? toBlock: \"latest\");\n        }\n\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n\n    on(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n\n    once(event: EventFilter | string, listener: Listener): this {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n\n    emit(eventName: EventFilter | string, ...args: Array<any>): boolean {\n        if (!this.provider) { return false; }\n\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventFilter | string): number {\n        if (!this.provider) { return 0; }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n\n    listeners(eventName?: EventFilter | string): Array<Listener> {\n        if (!this.provider) { return []; }\n\n        if (eventName == null) {\n            const result: Array<Listener> = [ ];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener)\n                });\n            }\n            return result;\n        }\n\n        return this._getRunningEvent(eventName).listeners();\n    }\n\n    removeAllListeners(eventName?: EventFilter | string): this {\n        if (!this.provider) { return this; }\n\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n\n        return this;\n    }\n\n    off(eventName: EventFilter | string, listener: Listener): this {\n        if (!this.provider) { return this; }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n\n    removeListener(eventName: EventFilter | string, listener: Listener): this {\n        return this.off(eventName, listener);\n    }\n\n}\n\nexport class Contract extends BaseContract {\n    // The meta-class properties\n    readonly [ key: string ]: ContractFunction | any;\n}\n\nexport class ContractFactory {\n\n    readonly interface: Interface;\n    readonly bytecode: string;\n    readonly signer: Signer;\n\n    constructor(contractInterface: ContractInterface, bytecode: BytesLike | { object: string }, signer?: Signer) {\n\n        let bytecodeHex: string = null;\n\n        if (typeof(bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        } else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        } else if (bytecode && typeof(bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = (<any>bytecode).object;\n        } else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") { bytecodeHex = \"0x\" + bytecodeHex; }\n\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic<InterfaceFunc>(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args: Array<any>): TransactionRequest {\n        let tx: TransactionRequest = { };\n\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof(args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key })\n        });\n\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n\n        return tx\n    }\n\n    async deploy(...args: Array<any>): Promise<Contract> {\n\n        let overrides: any = { };\n\n        // If 1 extra parameter was passed in, it contains overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            overrides = args.pop();\n        }\n\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n\n        // Resolve ENS names and promises in the arguments\n        const params = await resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n        params.push(overrides);\n\n        // Get the deployment transaction (with optional overrides)\n        const unsignedTx = this.getDeployTransaction(...params);\n\n        // Send the deployment transaction\n        const tx = await this.signer.sendTransaction(unsignedTx);\n\n        const address = getStatic<(tx: TransactionResponse) => string>(this.constructor, \"getContractAddress\")(tx);\n        const contract = getStatic<(address: string, contractInterface: ContractInterface, signer?: Signer) => Contract>(this.constructor, \"getContract\")(address, this.interface, this.signer);\n\n        // Add the modified wait that wraps events\n        addContractWait(contract, tx);\n\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n    }\n\n    attach(address: string): Contract {\n        return (<any>(this.constructor)).getContract(address, this.interface, this.signer);\n    }\n\n    connect(signer: Signer) {\n        return new (<{ new(...args: any[]): ContractFactory }>(this.constructor))(this.interface, this.bytecode, signer);\n    }\n\n    static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n\n        if (typeof(compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n\n        const abi = compilerOutput.abi;\n\n        let bytecode: any = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, signer);\n    }\n\n    static getInterface(contractInterface: ContractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n\n    static getContractAddress(tx: { from: string, nonce: BytesLike | BigNumber | number }): string {\n        return getContractAddress(tx);\n    }\n\n    static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n","export const version = \"contracts/5.7.0\";\n","import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { ContractFactory } from 'ethers';\nexport default function txDataByCompiled(abi, bytecode, args) {\n  // solc returns a string which is often passed instead of the json\n  if (typeof abi === 'string') abi = JSON.parse(abi);\n\n  // Construct a Contract Factory\n  var factory = new ContractFactory(abi, '0x' + bytecode);\n  var deployTransaction = factory.getDeployTransaction.apply(factory, _toConsumableArray(args));\n  return deployTransaction.data;\n}","import { generateAddress, toChecksumAddress, toBuffer } from 'ethereumjs-util';\nimport { addLeading0x } from './util';\nexport default function calculateContractAddress(creatorAddress, nonce) {\n  var addressBuffer = generateAddress(toBuffer(addLeading0x(creatorAddress)), toBuffer(nonce));\n  var address = addressBuffer.toString('hex');\n  return toChecksumAddress(addLeading0x(address));\n}","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\n\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nfunction _pack(type: string, value: any, isArray?: boolean): Uint8Array {\n    switch(type) {\n        case \"address\":\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return arrayify(value);\n        case \"bool\":\n            value = (value ? \"0x01\": \"0x00\");\n            if (isArray) { return zeroPad(value, 32); }\n            return arrayify(value);\n    }\n\n    let match =  type.match(regexNumber);\n    if (match) {\n        //let signed = (match[1] === \"int\")\n        let size = parseInt(match[2] || \"256\")\n\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n            logger.throwArgumentError(\"invalid number type\", \"type\", type)\n        }\n\n        if (isArray) { size = 256; }\n\n        value = BigNumber.from(value).toTwos(size);\n\n        return zeroPad(value, size / 8);\n    }\n\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n\n        if (String(size) !== match[1] || size === 0 || size > 32) {\n            logger.throwArgumentError(\"invalid bytes type\", \"type\", type)\n        }\n        if (arrayify(value).byteLength !== size) {\n            logger.throwArgumentError(`invalid value for ${ type }`, \"value\", value)\n        }\n        if (isArray) { return arrayify((value + Zeros).substring(0, 66)); }\n        return value;\n    }\n\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        if (count != value.length) {\n            logger.throwArgumentError(`invalid array length for ${ type }`, \"value\", value)\n        }\n        const result: Array<Uint8Array> = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return concat(result);\n    }\n\n    return logger.throwArgumentError(\"invalid type\", \"type\", type)\n}\n\n// @TODO: Array Enum\n\nexport function pack(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    if (types.length != values.length) {\n        logger.throwArgumentError(\"wrong number of values; expected ${ types.length }\", \"values\", values)\n    }\n    const tight: Array<Uint8Array> = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n\nexport function keccak256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashKeccak256(pack(types, values));\n}\n\nexport function sha256(types: ReadonlyArray<string>, values: ReadonlyArray<any>) {\n    return hashSha256(pack(types, values));\n}\n","export const version = \"solidity/5.7.0\";\n","import { utils as ethersUtils } from 'ethers';\nexport function keccak256(params) {\n  var types = [];\n  var values = [];\n  if (!Array.isArray(params)) {\n    types.push('string');\n    values.push(params);\n  } else {\n    params.forEach(function (p) {\n      types.push(p.type);\n      values.push(p.value);\n    });\n  }\n  return ethersUtils.solidityKeccak256(types, values);\n}\nexport var SIGN_PREFIX = '\\x19Ethereum Signed Message:\\n32';","/**\n * compress/decompress hex-strings to utf16 or base64\n * thx @juvian\n * @link https://stackoverflow.com/a/40471908/3443137\n */\n\nimport { removeLeading0x, addLeading0x } from './util';\nexport function compress(hex) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  hex = removeLeading0x(hex);\n\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) return Buffer.from(hex, 'hex').toString('base64');\n  var string = '';\n  while (hex.length % 4 != 0) {\n    // we need it to be multiple of 4\n    hex = '0' + hex;\n  }\n  for (var i = 0; i < hex.length; i += 4) {\n    // get char from ascii code which goes from 0 to 65536\n    string += String.fromCharCode(parseInt(hex.substring(i, i + 4), 16));\n  }\n  return string;\n}\nexport function decompress(compressedString) {\n  var base64 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // if base64:true, we use our own function because it results in a smaller output\n  if (base64 === true) {\n    var ret = Buffer.from(compressedString, 'base64').toString('hex');\n    return addLeading0x(ret);\n  }\n  var hex = '';\n  for (var i = 0; i < compressedString.length; i++) {\n    // get character ascii code and convert to hexa string, adding necessary 0s\n    hex += ((i == 0 ? '' : '000') + compressedString.charCodeAt(i).toString(16)).slice(-4);\n  }\n  hex = hex.toLowerCase();\n  return addLeading0x(hex);\n}","import { utils as ethersUtils } from 'ethers';\n/**\n * split signature-hex into parts\n * @param  {string} hexString\n * @return {{v: string, r: string, s: string}}\n */\nexport function fromString(hexString) {\n  var arr = ethersUtils.splitSignature(hexString);\n  return {\n    // convert \"v\" to hex\n    v: \"0x\".concat(arr.v.toString(16)),\n    r: arr.r,\n    s: arr.s\n  };\n}\n\n/**\n * merge signature-parts to one string\n * @param  {{v: string, r: string, s: string}} sig\n * @return {string} hexString\n */\nexport function toString(sig) {\n  return ethersUtils.joinSignature(sig);\n}","import createIdentity from './create-identity';\nimport * as publicKey from './public-key';\nimport decryptWithPrivateKey from './decrypt-with-private-key';\nimport encryptWithPublicKey from './encrypt-with-public-key';\nimport * as cipher from './cipher';\nimport publicKeyByPrivateKey from './public-key-by-private-key';\nimport recover from './recover';\nimport recoverPublicKey from './recover-public-key';\nimport sign from './sign';\nimport signTransaction from './sign-transaction';\nimport txDataByCompiled from './tx-data-by-compiled';\nimport calculateContractAddress from './calculate-contract-address';\nimport * as hash from './hash';\nimport * as hex from './hex';\nimport * as vrs from './vrs';\nimport * as util from './util';\nexport { createIdentity, publicKey, decryptWithPrivateKey, encryptWithPublicKey, cipher, publicKeyByPrivateKey, recover, recoverPublicKey, sign, signTransaction, txDataByCompiled, calculateContractAddress, hash, hex, vrs, util };\nexport default {\n  createIdentity: createIdentity,\n  publicKey: publicKey,\n  decryptWithPrivateKey: decryptWithPrivateKey,\n  encryptWithPublicKey: encryptWithPublicKey,\n  cipher: cipher,\n  publicKeyByPrivateKey: publicKeyByPrivateKey,\n  recover: recover,\n  recoverPublicKey: recoverPublicKey,\n  sign: sign,\n  signTransaction: signTransaction,\n  txDataByCompiled: txDataByCompiled,\n  calculateContractAddress: calculateContractAddress,\n  hash: hash,\n  hex: hex,\n  vrs: vrs,\n  util: util\n};"],"names":["ec","EC","require","browserCrypto","global","crypto","msCrypto","subtle","webkitSubtle","nodeCrypto","EC_GROUP_ORDER","Buffer","from","ZERO32","alloc","assert","condition","message","Error","isValidPrivateKey","privateKey","x","isBuffer","length","compare","randomBytes","size","arr","Uint8Array","getRandomValues","sha512","msg","Promise","resolve","result","createHash","update","digest","getAes","op","iv","key","data","importKey","name","then","cryptoKey","encAlgorithm","cipher","createCipheriv","firstChunk","secondChunk","final","concat","decipher","createDecipheriv","aesCbcEncrypt","aesCbcDecrypt","getPublic","keyFromPrivate","derive","privateKeyA","publicKeyB","keyA","keyB","keyFromPublic","Px","toArray","exports","publicKeyTo","opts","ephemPublicKey","ciphertext","macKey","ephemPrivateKey","hash","encryptionKey","slice","dataToMac","hmac","createHmac","hmacSha256Sign","mac","sig","b1","b2","res","i","equalConstTime","macGood","logger","Logger","Wallet","provider","value","isHexString","address","signingKey","SigningKey","defineReadOnly","computeAddress","publicKey","getAddress","throwArgumentError","mnemonic","phrase","hasMnemonic","srcMnemonic","path","defaultPath","locale","node","HDNode","derivePath","curve","match","Provider","this","_mnemonic","_signingKey","transaction","resolveProperties","tx","signature","signDigest","keccak256","serialize","joinSignature","hashMessage","domain","types","_TypedDataEncoder","throwError","operation","resolveName","populated","password","options","progressCallback","encryptKeystore","entropy","extraEntropy","arrayify","hexDataSlice","entropyToMnemonic","fromMnemonic","json","decryptJsonWallet","account","decryptJsonWalletSync","wordlist","Signer","ethersUtils","createIdentity","byteLength","innerHex","middleHex","createPrivateKey","wallet","stripHexPrefix","removeLeading0x","str","startsWith","substring","addLeading0x","uint8ArrayToHex","toString","hexToUnit8Array","compress","startsWith04","publicKeyConvert","decompress","startsWith02Or03","decompressed","toAddress","addressBuffer","pubToAddress","toBuffer","toChecksumAddress","stringify","compressedKey","parse","buf","ret","decryptWithPrivateKey","encrypted","twoStripped","encryptedBuffer","decrypt","decryptedBuffer","encryptWithPublicKey","pubString","encrypt","encryptedBuffers","publicKeyOfPrivateKey","privateToPublic","recoverPublicKey","sigOnly","recoveryNumber","pubKey","ecdsaRecover","recover","sigString","addressByPublicKey","sign","sigObj","secp256k1_sign","recoveryId","recid","signTransaction","rawTx","txOptions","arguments","undefined","publicKeyByPrivateKey","privateKeyBuffer","replace","Transaction","signedTx","serializedTx","_arrayLikeToArray","len","arr2","Array","_toConsumableArray","isArray","iter","Symbol","iterator","o","minLen","n","Object","prototype","call","constructor","test","TypeError","allowedTransactionKeys","chainId","gasLimit","gasPrice","nonce","to","type","accessList","maxFeePerGas","maxPriorityFeePerGas","customData","ccipReadEnabled","resolver","nameOrPromise","resolveAddresses","paramType","all","map","index","components","baseType","reject","makeError","argument","v","arrayChildren","populateTransaction","contract","fragment","args","overrides","inputs","shallowCopy","pop","checkArgumentCount","signer","override","check","__awaiter","resolvedAddress","resolved","interface","encodeFunctionData","ro","BigNumber","toNumber","accessListify","gas","intrinsic","bytes","add","roValue","isZero","payable","leftovers","keys","filter","l","JSON","join","addContractWait","wait","bind","confirmations","receipt","events","logs","log","event","deepCopy","parsed","parseLog","e","decode","topics","decodeEventLog","eventFragment","eventSignature","removeListener","getBlock","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","signerOrProvider","blockTag","push","deployTransaction","_deployed","decodeFunctionResult","outputs","code","buildDefault","constant","txRequest","sendTransaction","buildSend","getEventTag","topic","RunningEvent","tag","_listeners","listener","once","done","item","listenerCount","argsCopy","setTimeout","apply","ErrorRunningEvent","FragmentRunningEvent","contractInterface","getEventTopic","format","error","decodeError","errors","checkResultErrors","WildcardRunningEvent","BaseContract","addressOrName","getStatic","uniqueFilters","forEach","filters","encodeFilterTopics","warn","catch","uniqueNames","uniqueSignatures","functions","callStatic","buildPopulate","estimateGas","buildEstimate","signatures","_deployedPromise","getCode","contractAddress","deployed","VoidSigner","runningEvent","_runningEvents","eventName","_normalizeRunningEvent","getEvent","emit","_wrappedEmits","off","_checkRunningEvents","prepareEvent","addListener","wrappedEmit","_wrapEvent","getEmit","on","fromBlockOrBlockhash","toBlock","_getRunningEvent","fromBlock","getLogs","_addEventListener","run","reduce","accum","listeners","removeAllListeners","getContractAddress","Interface","Indexed","Contract","ContractFactory","bytecode","bytecodeHex","isBytes","hexlify","object","deploy","encodeDeploy","params","unsignedTx","getDeployTransaction","getContract","compilerOutput","abi","evm","getInterface","txDataByCompiled","factory","calculateContractAddress","creatorAddress","generateAddress","regexBytes","RegExp","regexNumber","regexArray","_pack","zeroPad","toUtf8Bytes","parseInt","String","toTwos","pack","values","tight","p","hashKeccak256","SIGN_PREFIX","hex","base64","string","fromCharCode","compressedString","charCodeAt","toLowerCase","fromString","hexString","r","s","vrs","util"],"sourceRoot":""}