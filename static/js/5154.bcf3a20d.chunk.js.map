{"version":3,"file":"static/js/5154.bcf3a20d.chunk.js","mappings":"8MAQA,SAASA,IAIL,IAAIC,GAAa,EAKbC,EAAoB,GAIpBC,EAAc,IAAIC,IAClBC,EAAW,CACXC,UAAW,SAAUC,GAEjB,OADAJ,EAAYK,IAAID,GACT,WAA0BJ,EAAYM,OAAOF,EAAiB,CACxE,EACDG,MAAO,SAAUC,EAAYC,GAOzB,GAAIX,EAAY,CACZ,IAAIY,EAAe,GAMnB,OALAV,EAAYW,SAAQ,SAAUP,GAC1BM,EAAaE,MAAKC,EAAAA,EAAAA,IAAqBT,EAAeI,EAAY,CAC9DC,mBAAoBA,IAE3B,IACMK,QAAQC,IAAIL,EACtB,CAEG,OAAO,IAAII,SAAQ,SAAUE,GACzBjB,EAAkBa,KAAK,CACnBK,UAAW,CAACT,EAAYC,GACxBO,QAASA,GAEhB,GAER,EACDE,IAAK,SAAUV,GAEX,OADAW,EAAAA,EAAAA,GAAUrB,EAAY,iHACfE,EAAYW,SAAQ,SAAUP,IACjCgB,EAAAA,EAAAA,IAAUhB,EAAeI,EAC5B,GACJ,EACDa,KAAM,WACFrB,EAAYW,SAAQ,SAAUP,IAC1BkB,EAAAA,EAAAA,IAAclB,EACjB,GACJ,EACDmB,MAAO,WAMH,OALAzB,GAAa,EACbC,EAAkBY,SAAQ,SAAUa,GAChC,IAAIP,EAAYO,EAAGP,UAAWD,EAAUQ,EAAGR,QAC3Cd,EAASK,MAAMkB,MAAMvB,GAAUwB,EAAAA,EAAAA,eAAc,IAAIC,EAAAA,EAAAA,QAAOV,IAAY,IAAQW,KAAKZ,EACpF,IACM,WACHlB,GAAa,EACbI,EAASmB,MACZ,CACJ,GAEL,OAAOnB,CACV,C,0BCtCD,IAAI2B,EALJ,WACI,IAAI3B,GAAW4B,EAAAA,EAAAA,GAAYjC,GAE3B,OADAkC,EAAAA,EAAAA,WAAU7B,EAASqB,MAAO,IACnBrB,CACV,C,mHCdD,SAAS8B,EAAeC,GACpB,IAAIC,GAAQJ,EAAAA,EAAAA,IAAY,WAAc,OAAOK,EAAAA,EAAAA,GAAYF,EAAW,IAOpE,IADeG,EAAAA,EAAAA,YAAWC,EAAAA,GAAqBC,SACjC,CACV,IAAuCC,GAA9BZ,EAAAA,EAAAA,SAAOa,EAAAA,EAAAA,UAASP,GAAU,GAAqB,IACxDF,EAAAA,EAAAA,YAAU,WAAc,OAAOG,EAAMO,SAASF,EAAe,GAAE,GAClE,CACD,OAAOL,CACV,C","sources":["../node_modules/framer-motion/dist/es/animation/animation-controls.mjs","../node_modules/framer-motion/dist/es/animation/use-animation.mjs","../node_modules/framer-motion/dist/es/value/use-motion-value.mjs"],"sourcesContent":["import { __spreadArray, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\nimport { setValues } from '../render/utils/setters.mjs';\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, __spreadArray([], __read(animation), false)).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n","import { animationControls } from './animation-controls.mjs';\nimport { useEffect } from 'react';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    var controls = useConstant(animationControls);\n    useEffect(controls.mount, []);\n    return controls;\n}\nvar useAnimation = useAnimationControls;\n\nexport { useAnimation, useAnimationControls };\n","import { __read } from 'tslib';\nimport { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    var value = useConstant(function () { return motionValue(initial); });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    var isStatic = useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = __read(useState(initial), 2), setLatest_1 = _a[1];\n        useEffect(function () { return value.onChange(setLatest_1); }, []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n"],"names":["animationControls","hasMounted","pendingAnimations","subscribers","Set","controls","subscribe","visualElement","add","delete","start","definition","transitionOverride","animations_1","forEach","push","animateVisualElement","Promise","all","resolve","animation","set","invariant","setValues","stop","stopAnimation","mount","_a","apply","__spreadArray","__read","then","useAnimation","useConstant","useEffect","useMotionValue","initial","value","motionValue","useContext","MotionConfigContext","isStatic","setLatest_1","useState","onChange"],"sourceRoot":""}