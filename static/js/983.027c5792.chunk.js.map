{"version":3,"file":"static/js/983.027c5792.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@ethersproject/sha2/src.ts/types.ts"],"sourcesContent":["\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    lastBaseFeePerGas: null | BigNumber;\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            lastBaseFeePerGas = block.baseFeePerGas;\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","export const version = \"abstract-provider/5.7.0\";\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.7.0\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","export const version = \"hash/5.7.0\";\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.7.0\";\n","export enum SupportedAlgorithm { sha256 = \"sha256\", sha512 = \"sha512\" };\n\n"],"names":["logger","Logger","ForkEvent","value","_isForkEvent","Description","Provider","checkAbstract","defineReadOnly","this","resolveProperties","block","getBlock","gasPrice","getGasPrice","catch","error","lastBaseFeePerGas","maxFeePerGas","maxPriorityFeePerGas","baseFeePerGas","BigNumber","mul","add","eventName","listener","on","off","_isProvider","allowedTransactionKeys","forwardErrors","Signer","blockTag","_checkProvider","provider","getBalance","getAddress","getTransactionCount","transaction","checkTransaction","tx","estimateGas","call","populateTransaction","signTransaction","signedTx","sendTransaction","getNetwork","network","chainId","getFeeData","name","resolveName","key","indexOf","throwArgumentError","shallowCopy","from","Promise","all","resolve","then","result","toLowerCase","to","__awaiter","address","hasEip1559","type","feeData","throwError","operation","nonce","gasLimit","code","getChainId","results","_isSigner","VoidSigner","message","_fail","domain","types","BaseX","alphabet","length","charAt","i","_alphabetMap","source","arrayify","digits","carry","j","base","push","string","k","_leader","q","TypeError","bytes","Uint8Array","byte","undefined","Error","reverse","Base58","version","id","text","keccak256","toUtf8Bytes","padding","fill","NegativeOne","Zero","One","MaxUint256","hexTrue","hexZeroPad","toHexString","hexFalse","domainFieldTypes","verifyingContract","salt","domainFieldNames","checkString","JSON","stringify","domainChecks","toString","hexlify","getBaseEncoder","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","v","lt","gt","toTwos","padOffset","hexConcat","slice","hexPadRight","encodeType","fields","map","join","TypedDataEncoder","Object","freeze","deepCopy","links","parents","subtypes","keys","forEach","uniqueNames","field","baseType","primaryTypes","filter","n","t","checkCircular","found","child","subtype","primaryType","st","sort","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","values","unshift","encodeData","hashStruct","callback","_visit","reduce","accum","domainFields","a","b","EIP712Domain","hashDomain","hash","encode","ensCache","isHexString","visit","domainValues","domainTypes","typesWithDomain","ripemd160","data","update","digest","sha256","sha512","computeHmac","algorithm","SupportedAlgorithm"],"sourceRoot":""}