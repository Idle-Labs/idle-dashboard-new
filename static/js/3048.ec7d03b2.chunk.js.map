{"version":3,"file":"static/js/3048.ec7d03b2.chunk.js","mappings":"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","sources":["components/ChakraCarousel/ChakraCarousel.js","hooks/useBoundingRect/useBoundingRect.ts","../node_modules/framer-motion/dist/es/animation/animation-controls.mjs","../node_modules/framer-motion/dist/es/animation/use-animation.mjs","../node_modules/framer-motion/dist/es/value/use-motion-value.mjs"],"sourcesContent":["//TODO: Properly handle user tabbing\n\nimport React, {\n  useLayoutEffect,\n  useCallback,\n  useEffect,\n  useState,\n  useMemo,\n  useRef\n} from \"react\";\n\nimport {\n  // useMediaQuery,\n  // useTheme,\n  // Progress,\n  VStack,\n  // Button,\n  Flex,\n  // Box\n} from \"@chakra-ui/react\";\n\nimport useBoundingRect from \"hooks/useBoundingRect/useBoundingRect\";\n// import { ChevronRightIcon, ChevronLeftIcon } from \"@chakra-ui/icons\";\nimport { motion, useAnimation, useMotionValue } from \"framer-motion\";\n\nconst MotionFlex = motion(Flex);\n\n// function percentage(x, y) {\n//   return 100 / (y / x)\n// }\n\nconst transitionProps = {\n  stiffness: 400,\n  type: \"spring\",\n  damping: 60,\n  mass: 3\n};\n\nexport const ChakraCarousel = ({\n  children,\n  gap,\n  activeItem: defaultActiveItem = 0,\n  enableDragging = false\n}) => {\n\n  const [trackIsActive, setTrackIsActive] = useState(false);\n  const [multiplier, setMultiplier] = useState(0.35);\n  const [sliderWidth, setSliderWidth] = useState(0);\n  const [activeItem, setActiveItem] = useState(defaultActiveItem);\n  const [constraint, setConstraint] = useState(0);\n  const [itemWidth, setItemWidth] = useState(0);\n\n  const initSliderWidth = useCallback((width) => setSliderWidth(width), []);\n\n  const positions = useMemo(\n    () => React.Children.map(children, (_, index) => -Math.abs((itemWidth + gap) * index)),\n    [children, itemWidth, gap]\n  );\n\n  // const { breakpoints } = useTheme();\n\n  // const [isBetweenBaseAndMd] = useMediaQuery(\n  //   `(min-width: ${breakpoints.base}) and (max-width: ${breakpoints.md})`\n  // );\n\n  // const [isBetweenMdAndXl] = useMediaQuery(\n  //   `(min-width: ${breakpoints.md}) and (max-width: ${breakpoints.xl})`\n  // );\n\n  // const [isGreaterThanXL] = useMediaQuery(`(min-width: ${breakpoints.xl})`);\n\n  useEffect(() => {\n    if (defaultActiveItem>0 || defaultActiveItem<positions.length-1){\n      setActiveItem(defaultActiveItem)\n    }\n  }, [positions, defaultActiveItem])\n\n  useEffect(() => {\n    // console.log('itemWidth', sliderWidth, gap, sliderWidth - gap)\n    setItemWidth(sliderWidth - gap);\n    setMultiplier(0.65);\n    setConstraint(1);\n    /*\n    if (isBetweenBaseAndMd) {\n      setItemWidth(sliderWidth - gap);\n      setMultiplier(0.65);\n      setConstraint(1);\n    }\n    if (isBetweenMdAndXl) {\n      setItemWidth(sliderWidth / 2 - gap);\n      setMultiplier(0.5);\n      setConstraint(2);\n    }\n    if (isGreaterThanXL) {\n      setItemWidth(sliderWidth / 3 - gap);\n      setMultiplier(0.35);\n      setConstraint(3);\n    }\n    */\n  }, [/*isBetweenBaseAndMd, isBetweenMdAndXl, isGreaterThanXL, */sliderWidth, gap]);\n\n  const sliderProps = {\n    setTrackIsActive,\n    initSliderWidth,\n    setActiveItem,\n    activeItem,\n    constraint,\n    itemWidth,\n    positions,\n    gap\n  };\n\n  const trackProps = {\n    setTrackIsActive,\n    enableDragging,\n    trackIsActive,\n    setActiveItem,\n    sliderWidth,\n    activeItem,\n    constraint,\n    multiplier,\n    itemWidth,\n    positions,\n    gap\n  };\n\n  const itemProps = {\n    setTrackIsActive,\n    trackIsActive,\n    setActiveItem,\n    activeItem,\n    constraint,\n    itemWidth,\n    positions,\n    gap\n  };\n\n  // console.log('itemProps', isBetweenBaseAndMd, isBetweenMdAndXl, isGreaterThanXL, sliderWidth, itemProps)\n\n  return (\n    <Slider {...sliderProps}>\n      <Track {...trackProps}>\n        {React.Children.map(children, (child, index) => (\n          <Item {...itemProps} index={index} key={index}>\n            {child}\n          </Item>\n        ))}\n      </Track>\n    </Slider>\n  );\n};\n\nconst Slider = ({\n  // setTrackIsActive,\n  initSliderWidth,\n  // setActiveItem,\n  // activeItem,\n  // constraint,\n  // itemWidth,\n  // positions,\n  children,\n  gap\n}) => {\n  const [ref, { width }] = useBoundingRect();\n\n  useLayoutEffect(() => initSliderWidth(Math.round(width)), [\n    width,\n    initSliderWidth\n  ]);\n\n  // const handleFocus = () => setTrackIsActive(true);\n\n  // const handleDecrementClick = () => {\n  //   setTrackIsActive(true);\n  //   !(activeItem === positions.length - positions.length) &&\n  //     setActiveItem((prev) => prev - 1);\n  // }\n\n  // const handleIncrementClick = () => {\n  //   setTrackIsActive(true);\n  //   !(activeItem === positions.length - constraint) &&\n  //     setActiveItem((prev) => prev + 1);\n  // }\n\n  return (\n    <Flex\n      flex={1}\n      ref={ref}\n      w={{ base: \"100%\", md: `calc(100% + ${gap}px)` }}\n      ml={{ base: 0, md: `-${gap / 2}px` }}\n      mt={0}\n      px={`${gap / 2}px`}\n      position=\"relative\"\n      overflow=\"hidden\"\n      _before={{\n        bgGradient: \"linear(to-r, base.d400, transparent)\",\n        position: \"absolute\",\n        w: `${gap / 2}px`,\n        content: \"''\",\n        zIndex: 1,\n        h: \"100%\",\n        left: 0,\n        top: 0\n      }}\n      _after={{\n        bgGradient: \"linear(to-l, base.d400, transparent)\",\n        position: \"absolute\",\n        w: `${gap / 2}px`,\n        content: \"''\",\n        zIndex: 1,\n        h: \"100%\",\n        right: 0,\n        top: 0\n      }}\n    >\n      {children}\n    </Flex>\n    /*\n    <>\n        <Flex w={`${itemWidth}px`} mt={`${gap / 2}px`} mx=\"auto\">\n          <Button\n            onClick={handleDecrementClick}\n            onFocus={handleFocus}\n            mr={`${gap / 3}px`}\n            color=\"gray.200\"\n            variant=\"link\"\n            minW={0}\n          >\n            <ChevronLeftIcon boxSize={9} />\n          </Button>\n\n          <Progress\n            value={percentage(activeItem, positions.length - constraint)}\n            alignSelf=\"center\"\n            borderRadius=\"2px\"\n            bg=\"base.d100\"\n            flex={1}\n            h=\"3px\"\n            sx={{\n              \"> div\": {\n                backgroundColor: \"gray.400\"\n              }\n            }}\n          />\n\n          <Button\n            onClick={handleIncrementClick}\n            onFocus={handleFocus}\n            ml={`${gap / 3}px`}\n            color=\"gray.200\"\n            variant=\"link\"\n            zIndex={2}\n            minW={0}\n          >\n            <ChevronRightIcon boxSize={9} />\n          </Button>\n        </Flex>\n    </>\n    */\n  );\n};\n\nconst Track = ({\n  setTrackIsActive,\n  enableDragging,\n  trackIsActive,\n  setActiveItem,\n  activeItem,\n  constraint,\n  multiplier,\n  itemWidth,\n  positions,\n  children\n}) => {\n  const [dragStartPosition, setDragStartPosition] = useState(0);\n  const controls = useAnimation();\n  const x = useMotionValue(0);\n  const node = useRef(null);\n\n  const handleDragStart = () => setDragStartPosition(positions[activeItem]);\n\n  const handleDragEnd = (_, info) => {\n    // console.log(info);\n    const distance = info.offset.x;\n    const velocity = info.velocity.x * multiplier;\n    const direction = velocity < 0 || distance < 0 ? 1 : -1;\n\n    const extrapolatedPosition =\n      dragStartPosition +\n      (direction === 1\n        ? Math.min(velocity, distance)\n        : Math.max(velocity, distance));\n\n    const closestPosition = positions.reduce((prev, curr) => {\n      return Math.abs(curr - extrapolatedPosition) <\n        Math.abs(prev - extrapolatedPosition)\n        ? curr\n        : prev;\n    }, 0);\n\n    if (!(closestPosition < positions[positions.length - constraint])) {\n      setActiveItem(positions.indexOf(closestPosition));\n      controls.start({\n        x: closestPosition,\n        transition: {\n          velocity: info.velocity.x,\n          ...transitionProps\n        }\n      });\n    } else {\n      setActiveItem(positions.length - constraint);\n      controls.start({\n        x: positions[positions.length - constraint],\n        transition: {\n          velocity: info.velocity.x,\n          ...transitionProps\n        }\n      });\n    }\n  };\n\n  const handleResize = useCallback(\n    () =>\n      controls.start({\n        x: positions[activeItem],\n        transition: {\n          ...transitionProps\n        }\n      }),\n    [activeItem, controls, positions]\n  );\n\n  const handleClick = useCallback(\n    (event) =>\n      node.current.contains(event.target)\n        ? setTrackIsActive(true)\n        : setTrackIsActive(false),\n    [setTrackIsActive]\n  );\n\n  const handleKeyDown = useCallback(\n    (event) => {\n      if (trackIsActive) {\n        if (activeItem < positions.length - constraint) {\n          if (event.key === \"ArrowRight\" || event.key === \"ArrowUp\") {\n            event.preventDefault();\n            setActiveItem((prev) => prev + 1);\n          }\n        }\n        if (activeItem > positions.length - positions.length) {\n          if (event.key === \"ArrowLeft\" || event.key === \"ArrowDown\") {\n            event.preventDefault();\n            setActiveItem((prev) => prev - 1);\n          }\n        }\n      }\n    },\n    [trackIsActive, setActiveItem, activeItem, constraint, positions.length]\n  );\n\n  useEffect(() => {\n    handleResize(positions);\n\n    // document.addEventListener(\"keydown\", handleKeyDown);\n    // document.addEventListener(\"mousedown\", handleClick);\n    // return () => {\n    //   document.removeEventListener(\"keydown\", handleKeyDown);\n    //   document.removeEventListener(\"mousedown\", handleClick);\n    // };\n  }, [handleClick, handleResize, handleKeyDown, positions]);\n\n  const dragProps = enableDragging ? {\n    drag:\"x\",\n    cursor:\"grab\",\n    onDragStart:handleDragStart,\n    onDragEnd:handleDragEnd,\n    _active:{cursor: \"grabbing\"},\n  } : {}\n\n  return (\n    <>\n      {itemWidth ? (\n        <VStack ref={node} spacing={5} alignItems=\"stretch\">\n          <MotionFlex\n            flex={1}\n            dragConstraints={node}\n            animate={controls}\n            style={{ x }}\n            minWidth=\"min-content\"\n            flexWrap=\"nowrap\"\n            {...dragProps}\n          >\n            {children}\n          </MotionFlex>\n        </VStack>\n      ) : null}\n    </>\n  );\n};\n\nconst Item = ({\n  setTrackIsActive,\n  setActiveItem,\n  activeItem,\n  constraint,\n  itemWidth,\n  positions,\n  children,\n  index,\n  gap\n}) => {\n  const [userDidTab, setUserDidTab] = useState(false);\n\n  const handleFocus = () => setTrackIsActive(true);\n\n  const handleBlur = () => {\n    userDidTab && index + 1 === positions.length && setTrackIsActive(false);\n    setUserDidTab(false);\n  };\n\n  const handleKeyUp = (event) =>\n    event.key === \"Tab\" &&\n    !(activeItem === positions.length - constraint) &&\n    setActiveItem(index);\n\n  const handleKeyDown = (event) => event.key === \"Tab\" && setUserDidTab(true);\n\n  return (\n    <Flex\n      onFocus={handleFocus}\n      onBlur={handleBlur}\n      onKeyUp={handleKeyUp}\n      onKeyDown={handleKeyDown}\n      w={`${itemWidth}px`}\n      _notLast={{\n        mr: `${gap}px`\n      }}\n    >\n      {children}\n    </Flex>\n  );\n};","import { requestTimeout } from 'helpers/'\nimport { useState, useCallback, useLayoutEffect } from \"react\";\n\n// let timeoutRequest: any = null;\n\nconst debounce = (delay: number = 0, callback: Function) => {\n  let timeoutId: any = null;\n  return (...args: any[]) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(callback, delay, args);\n\n    // if (timeoutRequest) {\n    //   timeoutRequest.clear();\n    // }\n    // timeoutRequest = requestTimeout(callback, delay);\n  };\n};\n\nexport type Dimensions = {\n  x: number\n  y: number\n  top: number\n  left: number\n  width: number\n  height: number\n  right: number\n  bottom: number\n}\n\nconst initialDimensions: Dimensions = {\n  x: 0,\n  y: 0,\n  top: 0,\n  left: 0,\n  width: 0,\n  height: 0,\n  right: 0,\n  bottom: 0\n}\n\nfunction getDimensionObject(node: any): Dimensions {\n  const rect = node.getBoundingClientRect();\n  return {\n    x: rect.x,\n    y: rect.y,\n    top: rect.top,\n    left: rect.left,\n    width: rect.width,\n    height: rect.height,\n    right: rect.right,\n    bottom: rect.bottom\n  };\n}\n\nexport default function useBoundingRect(delay: number = 0) {\n  const [node, setNode] = useState<any>(null);\n  const [dimensions, setDimensions] = useState<Dimensions>(initialDimensions);\n\n  const ref = useCallback((node: any) => {\n    setNode(node);\n  }, []);\n\n  useLayoutEffect(() => {\n    if (\"undefined\" !== typeof window && node) {\n      const measure = async () => {\n        window.requestAnimationFrame(() => {\n          // console.log('measure', getDimensionObject(node))\n          setDimensions(getDimensionObject(node))\n        });\n      }\n\n      measure();\n\n      const listener = debounce(delay || 100, measure);\n\n      window.addEventListener(\"resize\", listener);\n      window.addEventListener(\"scroll\", listener);\n      \n      return () => {\n        window.removeEventListener(\"resize\", listener);\n        window.removeEventListener(\"scroll\", listener);\n      };\n    }\n  }, [node, delay]);\n\n  return [ref, dimensions, node];\n}\n","import { __spreadArray, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\nimport { setValues } from '../render/utils/setters.mjs';\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, __spreadArray([], __read(animation), false)).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n","import { animationControls } from './animation-controls.mjs';\nimport { useEffect } from 'react';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    var controls = useConstant(animationControls);\n    useEffect(controls.mount, []);\n    return controls;\n}\nvar useAnimation = useAnimationControls;\n\nexport { useAnimation, useAnimationControls };\n","import { __read } from 'tslib';\nimport { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    var value = useConstant(function () { return motionValue(initial); });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    var isStatic = useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = __read(useState(initial), 2), setLatest_1 = _a[1];\n        useEffect(function () { return value.onChange(setLatest_1); }, []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n"],"names":["MotionFlex","motion","Flex","transitionProps","stiffness","type","damping","mass","ChakraCarousel","children","gap","activeItem","defaultActiveItem","enableDragging","useState","trackIsActive","setTrackIsActive","multiplier","setMultiplier","sliderWidth","setSliderWidth","setActiveItem","constraint","setConstraint","itemWidth","setItemWidth","initSliderWidth","useCallback","width","positions","useMemo","React","_","index","Math","abs","useEffect","length","sliderProps","trackProps","itemProps","Slider","Track","child","Item","key","useBoundingRect","ref","useLayoutEffect","round","flex","w","base","md","ml","mt","px","position","overflow","_before","bgGradient","content","zIndex","h","left","top","_after","right","dragStartPosition","setDragStartPosition","controls","useAnimation","x","useMotionValue","node","useRef","handleResize","start","transition","handleClick","event","current","contains","target","handleKeyDown","preventDefault","prev","dragProps","drag","cursor","onDragStart","onDragEnd","info","distance","offset","velocity","extrapolatedPosition","min","max","closestPosition","reduce","curr","indexOf","_active","spacing","alignItems","dragConstraints","animate","style","minWidth","flexWrap","userDidTab","setUserDidTab","onFocus","onBlur","onKeyUp","onKeyDown","_notLast","mr","debounce","delay","callback","timeoutId","clearTimeout","args","setTimeout","initialDimensions","y","height","bottom","getDimensionObject","rect","getBoundingClientRect","setNode","dimensions","setDimensions","window","measure","requestAnimationFrame","listener","addEventListener","removeEventListener","animationControls","hasMounted","pendingAnimations","subscribers","Set","subscribe","visualElement","add","delete","definition","transitionOverride","animations_1","forEach","push","animateVisualElement","Promise","all","resolve","animation","set","invariant","setValues","stop","stopAnimation","mount","_a","apply","__spreadArray","__read","then","useConstant","initial","value","motionValue","useContext","MotionConfigContext","isStatic","setLatest_1","onChange"],"sourceRoot":""}